/*
 *  Util.cpp
 *  Part of the QUantitative Image Toolbox
 *
 *  Copyright (c) 2015 Tobias Wood.
 *
 *  This Source Code Form is subject to the terms of the Mozilla Public
 *  License, v. 2.0. If a copy of the MPL was not distributed with this
 *  file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 */
#include <fstream>

#include "itkDivideImageFilter.h"
#include "itkMultiplyImageFilter.h"
#include "itkVectorMagnitudeImageFilter.h"

#include "Util.h"

namespace QI {

int GetDefaultThreads() {
    static const char *env_threads = getenv("QUIT_THREADS");
    static int         threads     = 4;
    static bool        checked     = false;
    if (!checked) {
        if (env_threads) {
            threads = atoi(env_threads);
            if ((threads < 1) || (threads > 1024)) {
                QI::Fail("Environment variable QUIT_THREADS was outside range 1-1024");
            }
        }
        checked = true;
    }
    return threads;
}

const std::string &GetVersion() {
// This file is generated by CMake to create a static version string
#include "VersionFile"
    return Version;
}

/*
 * This function checks the environment variable QUIT_EXT. If it does not exist,
 * a default value is returned. If it exists, and is one of the FSL output-types
 * the matching extension is returned. Otherwise, it is assumed that the
 * environment variable is a valid extension, including the ., and it is
 * returned.
 */
const std::string &OutExt() {
    static char *      env_ext = getenv("QUIT_EXT");
    static std::string ext;
    static bool        checked = false;
    if (!checked) {
        static std::map<std::string, std::string> valid_ext{
            {"NIFTI", ".nii"},
            {"NIFTI_PAIR", ".img"},
            {"NIFTI_GZ", ".nii.gz"},
            {"NIFTI_PAIR_GZ", ".img.gz"},
        };
        if (!env_ext) {
            std::cerr << "Environment variable QUIT_EXT is not valid, defaulting to NIFTI_GZ"
                      << std::endl;
            ext = valid_ext["NIFTI_GZ"];
        } else if (valid_ext.find(env_ext) == valid_ext.end()) {
            ext = env_ext;
        } else {
            ext = valid_ext[env_ext];
        }
        checked = true;
    }
    return ext;
}

std::string StripExt(const std::string &filename) {
    std::size_t dot = filename.find_last_of(".");
    if (dot != std::string::npos) {
        /* Deal with .nii.gz files */
        if (filename.substr(dot) == ".gz") {
            dot = filename.find_last_of(".", dot - 1);
        }
        return filename.substr(0, dot);
    } else {
        return filename;
    }
}

std::string GetExt(const std::string &filename) {
    std::size_t dot = filename.find_last_of(".");
    if (dot != std::string::npos) {
        /* Deal with .nii.gz files */
        if (filename.substr(dot) == ".gz") {
            dot = filename.find_last_of(".", dot - 1);
        }
        return filename.substr(dot);
    } else {
        QI::Fail("No extension found in string: {}", filename);
    }
}

std::string Basename(const std::string &path) {
    std::size_t slash = path.find_last_of("/");
    if (slash != std::string::npos) {
        return StripExt(path.substr(slash + 1));
    } else {
        return StripExt(path);
    }
}

std::mt19937_64::result_type RandomSeed() {
    static std::random_device rd;
    static std::mt19937_64    rng;
    static bool               init = false;
    std::mutex                seed_mtx;
    if (!init) {
        rng = std::mt19937_64(rd());
    }
    seed_mtx.lock();
    std::mt19937_64::result_type r = rng();
    seed_mtx.unlock();
    return r;
}

} // namespace QI
